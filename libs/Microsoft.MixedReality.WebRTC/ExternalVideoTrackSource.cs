// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Runtime.InteropServices;
using Microsoft.MixedReality.WebRTC.Interop;

namespace Microsoft.MixedReality.WebRTC
{
    /// <summary>
    /// Request sent to an external video source via its registered callback to generate
    /// a new video frame for the track(s) connected to it.
    /// </summary>
    public ref struct FrameRequest
    {
        /// <summary>
        /// Interop handle to the native video track source this request is for.
        /// </summary>
        public IntPtr SourceHandle;

        /// <summary>
        /// Unique request identifier, for error checking.
        /// </summary>
        public uint RequestId;

        /// <summary>
        /// Frame timestamp, in milliseconds. This corresponds to the time when the request
        /// was made to the native video track source.
        /// </summary>
        public long TimestampMs;

        /// <summary>
        /// Complete the frame request by push the generated frame down the WebRTC pipeline.
        /// </summary>
        /// <param name="frame">The frame newly generated by the external video source.</param>
        public void Complete(I420AVideoFrame frame)
        {
            ExternalVideoTrackSourceInterop.CompleteExternalI420AVideoFrameRequest(SourceHandle, RequestId, frame);
        }

        /// <summary>
        /// Complete the frame request by push the generated frame down the WebRTC pipeline.
        /// </summary>
        /// <param name="frame">The frame newly generated by the external video source.</param>
        public void Complete(ARGBVideoFrame frame)
        {
            ExternalVideoTrackSourceInterop.CompleteExternalArgb32VideoFrameRequest(SourceHandle, RequestId, frame);
        }
    }

    /// <summary>
    /// Callback invoked when the WebRTC pipeline needs an external video source to generate
    /// a new video frame for the track(s) it is connected to.
    /// </summary>
    /// <param name="request">The request to fulfill with a new I420A video frame.</param>
    public delegate void I420AVideoFrameRequestDelegate(FrameRequest request);

    /// <summary>
    /// Callback invoked when the WebRTC pipeline needs an external video source to generate
    /// a new video frame for the track(s) it is connected to.
    /// </summary>
    /// <param name="request">The request to fulfill with a new ARGB32 video frame.</param>
    public delegate void Argb32VideoFrameRequestDelegate(FrameRequest request);

    /// <summary>
    /// Video source for WebRTC video tracks based on a custom source
    /// of video frames managed by the user and external to the WebRTC
    /// implementation.
    /// 
    /// This class is used to inject into the WebRTC engine a video track
    /// whose frames are produced by a user-managed source the WebRTC engine
    /// knows nothing about, like programmatically generated frames, including
    /// frames not strictly of video origin like a 3D rendered scene, or frames
    /// coming from a specific capture device not supported natively by WebRTC.
    /// This class serves as an adapter for such video frame sources.
    /// </summary>
    public class ExternalVideoTrackSource : WrapperBase
    {
        /// <summary>
        /// Peer connection this video track source is part of.
        /// </summary>
        public PeerConnection PeerConnection { get; private set; }

        /// <summary>
        /// Handle to native peer connection C++ object.
        /// </summary>
        protected PeerConnectionHandle _nativePeerHandle = new PeerConnectionHandle();

        /// <summary>
        /// GC handle to frame request callback args keeping the delegate alive
        /// while the callback is registered with the native implementation.
        /// </summary>
        protected GCHandle _frameRequestCallbackArgsHandle;

        internal unsafe ExternalVideoTrackSource(PeerConnection peer, PeerConnectionHandle nativePeerHandle, IntPtr nativeHandle,
            GCHandle frameRequestCallbackArgsHandle) : base(nativeHandle)
        {
            PeerConnection = peer;
            _nativePeerHandle = nativePeerHandle.MakeCopy();
            _frameRequestCallbackArgsHandle = frameRequestCallbackArgsHandle;
        }

        #region IDisposable support

        /// <inheritdoc/>
        protected override void AddRef()
        {
            ExternalVideoTrackSourceInterop.ExternalVideoTrackSource_AddRef(_nativeHandle);
        }

        /// <inheritdoc/>
        protected override void RemoveRef()
        {
            ExternalVideoTrackSourceInterop.ExternalVideoTrackSource_RemoveRef(_nativeHandle);
        }

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (_nativeHandle != null)
            {
                // Remove the track from the peer connection
                PeerConnectionInterop.PeerConnection_RemoveLocalVideoTracksFromSource(_nativePeerHandle, _nativeHandle);

                // Unregister and release the track callbacks. This needs to be explicitly unregistered because
                // the C++ implementation might be kept alive even past the base.Dispose() below, but the registered
                // callback arguments will not survive this C# object being garbage-collected.
                ExternalVideoTrackSourceInterop.ExternalVideoTrackSource_Shutdown(_nativeHandle);
                _frameRequestCallbackArgsHandle.Free();

                // Release the reference to the peer connection owning the track
                _nativePeerHandle.Close();
            }

            if (disposing)
            {
                PeerConnection = null;
            }

            base.Dispose(disposing);
        }

        #endregion
    }
}
